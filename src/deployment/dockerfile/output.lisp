;;;; output.lisp --- Transform instances of model classes into a Dockerfile.
;;;;
;;;; Copyright (C) 2018-2022 Jan Moringen
;;;;
;;;; Author: Jan Moringen <jmoringe@techfak.uni-bielefeld.de>

(cl:in-package #:build-generator.deployment.dockerfile)

;;; Output utilities

(defun write-copy-and-run-commands (stream script-directory scripts)
  (format stream "COPY 窿 /tmp/A@
                    @
                    窿艺黼溟堍淋苘蠢驭沅堍邯淋苘蠢驭箬堍繇鸠淋苘蠢驭蝽堍繇鸠邯淋^2%}"
          (map 'list #'third scripts) script-directory scripts))

(defun make-script-directory (sub-directory)
  (let ((name (util:safe-name sub-directory)))
    (make-pathname :directory `(:relative "scripts" ,name))))

(defun make-script-name (name script-directory output-directory)
  (let* ((script/relative (make-pathname :name      (util:safe-name name)
                                         :type      "sh"
                                         :defaults  script-directory))
         (script/absolute (merge-pathnames script/relative output-directory)))
    (values script/relative script/absolute)))

(defun call-with-output-to-script (continuation name
                                   script-directory output-directory)
  (let+ (((&values relative-name absolute-name)
          (make-script-name name script-directory output-directory)))
    (ensure-directories-exist absolute-name)
    (with-output-to-file (stream absolute-name :if-exists :supersede)
      (format stream "set -e2%")
      (funcall continuation stream))
    (values relative-name absolute-name)))

(defmacro with-output-to-script ((stream-var name script-directory output-directory)
                                 &body body)
  `(call-with-output-to-script (lambda (,stream-var) ,@body)
                               ,name ,script-directory ,output-directory))

;;; Context
;;;
;;; Information regarding the output target and global configuration
;;; that should be available in all output operations.

(defclass context ()
  ((%directory    :initarg :directory
                  :reader  directory)
   (%dockerfile   :initarg :dockerfile
                  :reader  dockerfile)
   (%run-strategy :initarg :run-strategy
                  :reader  run-strategy)))

(defclass stream-context ()
  ((%parent :initarg :parent
            :reader  parent)
   (%stream :initarg :stream
            :reader  stream1)))

(defmethod directory ((context stream-context))
  (directory (parent context)))

(defmethod dockerfile ((context stream-context))
  (dockerfile (parent context)))

(defmethod run-strategy ((context stream-context))
  (run-strategy (parent context)))

;;; Output for `dockerfile'

(defmethod output ((object dockerfile) (context context))
  (let ((filename (dockerfile context)))
    (ensure-directories-exist filename)
    (with-output-to-file (stream filename :if-exists :supersede)
      (output object (make-instance 'stream-context :parent context
                                                    :stream stream)))))

(defmethod output ((object dockerfile) (context stream-context))
  ;; Header comment and base image.
  (deploy:print-heading
   (stream1 context) "This file is automatically generated.")

  (map nil (rcurry #'output context) (stages object)))

;;; Output for `stage'

(defmethod output ((object stage-mixin) (context stream-context))
  (let ((stream (stream1 context)))
    ;; Write scripts and RUN directives for project builders.
    (map nil (lambda (step)
               (with-simple-restart
                   (continue "@<Skip writing commands for A@:>" step)
                 (output step context)
                 (format stream "2%")))
         (steps object))))

(defmethod output ((object pseudo-stage) (context stream-context))
  (let ((stream (stream1 context)))
    (format stream "FROM A2%" (base-image object)))

  (call-next-method))

(defmethod output ((object stage) (context stream-context))
  (let ((stream (stream1 context))
        (name   (model:name object)))
    (deploy:print-heading stream (format nil "Stage A" name))
    (format stream "FROM A@[ as A]2%" (base-image object) name))

  (call-next-method))

;;; `command-step'

(defmethod output ((object command-step) (context stream-context))
  (let ((stream (stream1 context)))
    (deploy:print-heading stream (title object))
    (format stream "RUN A%" (deploy:command object))))

;;; `script-step'

(defmethod output ((object script-step) (context stream-context))
  (let+ ((stream (stream1 context))
         ((&accessors-r/o (name model:name) title (command deploy:command))
          object))
    (deploy:print-heading stream title)
    (write-scripts-and-run-commands*
     `((,name ,title ,command)) "global" context)
    (format stream "2%")))

;;; `copy-step'

(defmethod output ((object copy-step) (context stream-context))
  (let+ ((stream (stream1 context))
         ((&accessors-r/o from-stage source target) object)
         (from-name (model:name from-stage)))
    (deploy:print-heading stream (format nil "Copy results from stage A"
                                         from-name))
    (format stream "COPY --from=A \"A\" \"A\"%"
            from-name source target)))

;;; `dockerfile-job'

(defmethod output ((object dockerfile-job) (context stream-context))
  (deploy:print-heading (stream1 context) (model:name object))
  (let ((run-strategy (run-strategy context)))
    (write-scripts-and-run-commands object run-strategy context)))

;;; Scripts

(defun write-scripts-and-run-commands* (steps sub-directory context)
  (let ((stream           (stream1 context))
        (output-directory (directory context))
        (script-directory (make-script-directory sub-directory))
        (runs             '()))
    (map nil (lambda+ ((name title command))
               (let ((script/relative
                       (with-output-to-script
                           (stream name script-directory output-directory)
                         (write-string command stream))))
                 (appendf runs (list (list title name script/relative)))))
         steps)

    (write-copy-and-run-commands stream script-directory runs)))

(defmethod write-scripts-and-run-commands ((job      t)
                                           (strategy (eql :one-file-per-builder))
                                           (context  stream-context))
  (let* ((output-directory  (directory context))
         (project-directory (deploy:job-full-name (model:specification job)))
         (script-directory  (make-script-directory project-directory))
         (runs              '()))
    (map nil (lambda (builder)
               (let* ((name    (model:name (aspect builder)))
                      (command (trim-command (deploy:command builder)))
                      (script/relative
                        (with-output-to-script
                            (stream name script-directory output-directory)
                          (write-string command stream))))
                 (appendf runs (list (list name
                                           project-directory
                                           script/relative)))))
         (builders job))

    (write-copy-and-run-commands (stream1 context) script-directory runs)))

(defmethod write-scripts-and-run-commands ((job      t)
                                           (strategy (eql :one-file-for-all-builders))
                                           (context  stream-context))
  (let* ((output-directory  (directory context))
         (project-directory (deploy:job-full-name (model:specification job)))
         (script-directory  (make-script-directory project-directory))
         (script/relative
           (with-output-to-script (stream "builders" script-directory output-directory)
             (map nil (lambda (builder)
                        (let ((name    (model:name (aspect builder)))
                              (command (trim-command (deploy:command builder))))
                          (deploy:print-heading stream (format nil "Aspect A" name)) ; TODO should take format-control &rest format-arguments
                          ;; Execute COMMAND in a sub-shell so that
                          ;; e.g. changing the current directory or
                          ;; the environment does not affect the next
                          ;; step.
                          ;;
                          ;; Note that we must not indent the
                          ;; sub-shell command string as that could
                          ;; break HERE documents and maybe other
                          ;; things.
                          (format stream "(@
                                           @<@;A:>@
                                          )2%" command)))
                  (builders job)))))

    (write-copy-and-run-commands
     (stream1 context) script-directory
     `(("Builders" ,project-directory ,script/relative)))))
